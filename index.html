<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake - Culebrita Futurista</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', monospace;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a1a;
            color: #00ffff;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
            padding-bottom: 20px;
            touch-action: pan-y; /* Permitir scroll vertical pero no horizontal */
        }

        /* Prevenir scroll cuando el juego est√° activo */
        body.game-active {
            overflow: hidden;
            height: 100vh;
        }

        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                touch-action: manipulation;
            }
        }

        /* Fondo con efecto de estrellas */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(2px 2px at 20% 30%, #00ffff, transparent),
                radial-gradient(2px 2px at 60% 70%, #ff00ff, transparent),
                radial-gradient(1px 1px at 50% 50%, #ffffff, transparent),
                radial-gradient(1px 1px at 80% 10%, #00ffff, transparent),
                radial-gradient(2px 2px at 90% 80%, #ff00ff, transparent);
            background-size: 200% 200%;
            animation: stars 20s linear infinite;
            opacity: 0.6;
            z-index: 0;
        }

        @keyframes stars {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        .container {
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #00ffff;
            box-shadow: 
                0 0 30px #00ffff,
                inset 0 0 30px rgba(0, 255, 255, 0.1);
            position: relative;
            z-index: 1;
            backdrop-filter: blur(10px);
            max-width: 100%;
            width: 100%;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }

            h1 {
                font-size: 2em;
            }

            canvas {
                width: 100% !important;
                max-width: 400px;
                height: auto !important;
            }
            
            .controls-panel {
                flex-direction: column;
                gap: 10px;
            }
            
            .controls-panel button {
                width: 100%;
            }
        }

        h1 {
            margin-bottom: 20px;
            color: #00ffff;
            font-size: 3em;
            font-weight: 900;
            text-shadow: 
                0 0 10px #00ffff,
                0 0 20px #00ffff,
                0 0 30px #00ffff;
            letter-spacing: 3px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 
                    0 0 10px #00ffff,
                    0 0 20px #00ffff,
                    0 0 30px #00ffff;
            }
            to {
                text-shadow: 
                    0 0 20px #00ffff,
                    0 0 30px #00ffff,
                    0 0 40px #00ffff,
                    0 0 50px #00ffff;
            }
        }

        .score {
            font-size: 28px;
            margin-bottom: 25px;
            color: #ff00ff;
            font-weight: 700;
            text-shadow: 
                0 0 10px #ff00ff,
                0 0 20px #ff00ff;
            letter-spacing: 2px;
        }

        #score {
            color: #00ffff;
            text-shadow: 
                0 0 10px #00ffff,
                0 0 20px #00ffff;
            font-size: 1.2em;
        }

        canvas {
            border: 3px solid #00ffff;
            background: #000;
            display: block;
            margin: 0 auto;
            box-shadow: 
                0 0 20px #00ffff,
                inset 0 0 30px rgba(0, 255, 255, 0.1);
            border-radius: 5px;
            max-width: 100%;
            height: auto;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        .instructions {
            margin-top: 25px;
            color: #00ffff;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0.8;
        }

        .game-over {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border-radius: 20px;
            border: 3px solid #ff0080;
            text-align: center;
            z-index: 1000;
            box-shadow: 
                0 0 40px #ff0080,
                inset 0 0 30px rgba(255, 0, 128, 0.2);
            backdrop-filter: blur(10px);
        }

        .game-over.show {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .game-over h2 {
            color: #ff0080;
            margin-bottom: 20px;
            font-size: 2.5em;
            font-weight: 900;
            text-shadow: 
                0 0 10px #ff0080,
                0 0 20px #ff0080,
                0 0 30px #ff0080;
            letter-spacing: 3px;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .game-over p {
            color: #00ffff;
            font-size: 1.5em;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #00ffff;
        }

        #finalScore {
            color: #ff00ff;
            font-weight: 700;
            text-shadow: 0 0 10px #ff00ff;
        }

        button {
            padding: 15px 35px;
            font-size: 18px;
            background: linear-gradient(135deg, #00ffff, #0080ff);
            color: #000;
            border: 2px solid #00ffff;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 10px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            box-shadow: 
                0 0 20px #00ffff,
                inset 0 0 20px rgba(0, 255, 255, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #ff00ff, #ff0080);
            border-color: #ff00ff;
            color: #fff;
            transform: scale(1.1);
            box-shadow: 
                0 0 30px #ff00ff,
                inset 0 0 30px rgba(255, 0, 255, 0.3);
        }

        button:active {
            transform: scale(1.05);
        }

        .controls-panel {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .controls-panel button {
            padding: 10px 20px;
            font-size: 14px;
            margin: 0;
        }

        .info-panel {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            max-height: 180px;
            overflow-y: scroll;
            overflow-x: hidden;
            text-align: left;
            font-size: 12px;
            scrollbar-width: thin;
            scrollbar-color: #00ffff rgba(0, 0, 0, 0.5);
        }

        .info-panel::-webkit-scrollbar {
            width: 10px;
        }

        .info-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        .info-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #00ffff, #0080ff);
            border-radius: 10px;
            box-shadow: 0 0 10px #00ffff;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .info-panel::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #ff00ff, #ff0080);
            box-shadow: 0 0 15px #ff00ff;
        }

        .info-panel h3 {
            color: #00ffff;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px #00ffff;
        }

        .info-panel ul {
            list-style: none;
            padding-left: 0;
        }

        .info-panel li {
            margin: 8px 0;
            color: #aaa;
            padding-left: 20px;
            position: relative;
        }

        .info-panel li::before {
            content: '‚ñ∏';
            position: absolute;
            left: 0;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }

        .speed-indicator {
            margin-top: 15px;
            font-size: 14px;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }

        .records-panel {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #ff00ff;
            border-radius: 10px;
            padding: 15px;
            max-height: 150px;
            overflow-y: scroll;
            overflow-x: hidden;
            display: none;
            scrollbar-width: thin;
            scrollbar-color: #ff00ff rgba(0, 0, 0, 0.5);
        }

        .records-panel::-webkit-scrollbar {
            width: 10px;
        }

        .records-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(255, 0, 255, 0.2);
        }

        .records-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #ff00ff, #ff0080);
            border-radius: 10px;
            box-shadow: 0 0 10px #ff00ff;
            border: 1px solid rgba(255, 0, 255, 0.3);
        }

        .records-panel::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #00ffff, #0080ff);
            box-shadow: 0 0 15px #00ffff;
        }

        .records-panel.show {
            display: block;
        }

        .records-panel h3 {
            color: #ff00ff;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px #ff00ff;
        }

        .record-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            margin: 5px 0;
            background: rgba(255, 0, 255, 0.1);
            border-radius: 5px;
            border-left: 3px solid #ff00ff;
        }

        .record-score {
            color: #00ffff;
            font-weight: bold;
        }

        .record-date {
            color: #aaa;
            font-size: 11px;
        }

        /* Controles m√≥viles */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .mobile-controls-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .mobile-controls-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .mobile-btn {
            width: 70px;
            height: 70px;
            border-radius: 15px;
            border: 3px solid #00ffff;
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 
                0 0 20px #00ffff,
                inset 0 0 20px rgba(0, 255, 255, 0.2);
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: auto;
        }

        .mobile-btn:active {
            background: rgba(0, 255, 255, 0.3);
            transform: scale(0.9);
            box-shadow: 
                0 0 30px #00ffff,
                inset 0 0 30px rgba(0, 255, 255, 0.4);
        }

        .mobile-btn.up,
        .mobile-btn.down,
        .mobile-btn.left,
        .mobile-btn.right {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 128, 255, 0.2));
        }

        .mobile-btn.up:active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 128, 255, 0.4));
        }

        .mobile-btn.down:active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 128, 255, 0.4));
        }

        .mobile-btn.left:active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 128, 255, 0.4));
        }

        .mobile-btn.right:active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 128, 255, 0.4));
        }

        /* Mostrar controles solo en m√≥viles */
        @media (max-width: 768px) {
            .mobile-controls {
                display: block;
            }

            .instructions {
                margin-bottom: 100px;
            }

            body {
                padding-bottom: 150px;
            }

            .container {
                margin-bottom: 20px;
            }
        }

        @media (max-width: 480px) {
            .mobile-btn {
                width: 60px;
                height: 60px;
                font-size: 25px;
            }

            .mobile-controls-row {
                gap: 8px;
            }

            h1 {
                font-size: 1.5em;
            }

            .score {
                font-size: 20px;
            }

            .speed-indicator {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚óä SNAKE ‚óä</h1>
        <div class="score">SCORE: <span id="score">0</span></div>
        <div class="speed-indicator">VELOCIDAD: NIVEL <span id="speedLevel">1</span></div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div class="controls-panel">
            <button onclick="toggleFullscreen()">‚õ∂ PANTALLA COMPLETA</button>
            <button onclick="toggleRecords()">üìä HISTORIAL</button>
            <button onclick="toggleInfo()">‚Ñπ INFO</button>
        </div>

        <div class="info-panel" id="infoPanel" style="display: none;">
            <h3>‚óä CONTROLES Y FUNCIONES ‚óä</h3>
            <ul>
                <li><strong>Flechas del teclado (PC):</strong> Mover la serpiente en 4 direcciones</li>
                <li><strong>Controles t√°ctiles (M√≥vil):</strong> Usa los botones en la parte inferior</li>
                <li><strong>Velocidad progresiva:</strong> Aumenta cada 5 puntos autom√°ticamente</li>
                <li><strong>Comer manzanas:</strong> +10 puntos, crece la serpiente</li>
                <li><strong>Pantalla completa:</strong> Bot√≥n superior para mejor experiencia visual</li>
                <li><strong>Historial:</strong> Ver todos tus r√©cords anteriores (top 10)</li>
                <li><strong>Efectos visuales:</strong> Destello al comer, animaciones fluidas</li>
                <li><strong>Objetivo:</strong> Consigue el puntaje m√°s alto posible</li>
                <li><strong>Peligro:</strong> Evita chocar contra las paredes o tu propia cola</li>
                <li><strong>Niveles de velocidad:</strong> El juego se vuelve m√°s r√°pido progresivamente</li>
                <li><strong>Serpiente realista:</strong> Cara robusta con ojos que siguen la direcci√≥n</li>
                <li><strong>Manzanas animadas:</strong> Efecto pulsante y destello al ser comidas</li>
                <li><strong>Guardado autom√°tico:</strong> Todos los r√©cords se guardan localmente</li>
                <li><strong>Dise√±o futurista:</strong> Estilo ne√≥n con efectos visuales avanzados</li>
                <li><strong>Controles intuitivos:</strong> Usa las flechas para mover f√°cilmente</li>
                <li><strong>Estrategia:</strong> Planea tus movimientos para evitar auto-colisi√≥n</li>
            </ul>
        </div>

        <div class="records-panel" id="recordsPanel">
            <h3>‚óä HISTORIAL DE R√âCORDS ‚óä</h3>
            <div id="recordsList"></div>
        </div>

        <div class="instructions">
            ‚¨Ü ‚¨á ‚¨Ö ‚û° NAVEGAR
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>‚óä GAME OVER ‚óä</h2>
        <p>SCORE FINAL: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">REINICIAR</button>
    </div>

    <!-- Controles m√≥viles -->
    <div class="mobile-controls">
        <div class="mobile-controls-wrapper">
            <div class="mobile-controls-row">
                <button class="mobile-btn up" id="btnUp">‚¨Ü</button>
            </div>
            <div class="mobile-controls-row">
                <button class="mobile-btn left" id="btnLeft">‚¨Ö</button>
                <button class="mobile-btn down" id="btnDown">‚¨á</button>
                <button class="mobile-btn right" id="btnRight">‚û°</button>
            </div>
        </div>
    </div>

    <script>
        // Obtener el canvas y contexto
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const speedLevelElement = document.getElementById('speedLevel');
        const infoPanelElement = document.getElementById('infoPanel');
        const recordsPanelElement = document.getElementById('recordsPanel');
        const recordsListElement = document.getElementById('recordsList');

        // Configuraci√≥n
        const gridSize = 20; // Tama√±o de cada cuadro
        const tileCount = canvas.width / gridSize; // N√∫mero de cuadros en cada fila/columna

        // Estado del juego
        let snake = [{ x: 10, y: 10 }]; // Serpiente inicial (solo la cabeza)
        let food = { x: 15, y: 15 }; // Posici√≥n inicial de la comida
        let dx = 0; // Direcci√≥n X (0 = sin movimiento)
        let dy = 0; // Direcci√≥n Y (0 = sin movimiento)
        let score = 0; // Puntaje
        let gameRunning = true; // Estado del juego
        let baseSpeed = 150; // Velocidad base en milisegundos
        let currentSpeed = 150; // Velocidad actual
        let speedLevel = 1; // Nivel de velocidad actual
        let gameInterval = null; // Intervalo del juego

        // Funci√≥n para actualizar la velocidad del juego
        function updateGameSpeed() {
            // Calcular nuevo nivel de velocidad (cada 5 puntos aumenta)
            const newSpeedLevel = Math.floor(score / 5) + 1;
            
            if (newSpeedLevel !== speedLevel) {
                speedLevel = newSpeedLevel;
                speedLevelElement.textContent = speedLevel;
                
                // Calcular nueva velocidad (m√°s r√°pida = menor intervalo)
                // Velocidad base 150ms, reduce 5ms por nivel, m√≠nimo 50ms
                currentSpeed = Math.max(50, baseSpeed - (speedLevel - 1) * 5);
                
                // Reiniciar intervalo con nueva velocidad
                if (gameInterval) {
                    clearInterval(gameInterval);
                }
                
                if (gameRunning) {
                    gameInterval = setInterval(() => {
                        if (gameRunning) {
                            moveSnake();
                        }
                    }, currentSpeed);
                }
            }
        }

        // Generar nueva comida en posici√≥n aleatoria
        function generateFood() {
            food = {
                x: Math.floor(Math.random() * tileCount),
                y: Math.floor(Math.random() * tileCount)
            };
        }

        // Funciones para pantalla completa
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    alert('Error al entrar en pantalla completa: ' + err.message);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Detectar cambios de pantalla completa
        document.addEventListener('fullscreenchange', () => {
            const fullscreenBtn = document.querySelector('[onclick="toggleFullscreen()"]');
            if (fullscreenBtn) {
                if (document.fullscreenElement) {
                    fullscreenBtn.textContent = '‚õ∂ SALIR PANTALLA COMPLETA';
                } else {
                    fullscreenBtn.textContent = '‚õ∂ PANTALLA COMPLETA';
                }
            }
        });

        // Toggle panel de informaci√≥n
        function toggleInfo() {
            const isVisible = infoPanelElement.style.display !== 'none';
            infoPanelElement.style.display = isVisible ? 'none' : 'block';
            
            // Cerrar records si est√° abierto
            if (recordsPanelElement.classList.contains('show')) {
                recordsPanelElement.classList.remove('show');
            }
        }

        // Toggle panel de r√©cords
        function toggleRecords() {
            recordsPanelElement.classList.toggle('show');
            
            // Cerrar info si est√° abierto
            if (infoPanelElement.style.display !== 'none') {
                infoPanelElement.style.display = 'none';
            }
            
            // Cargar y mostrar r√©cords
            if (recordsPanelElement.classList.contains('show')) {
                loadRecords();
            }
        }

        // Cargar y mostrar historial de r√©cords
        function loadRecords() {
            const records = getRecords();
            recordsListElement.innerHTML = '';
            
            if (records.length === 0) {
                recordsListElement.innerHTML = '<div style="color: #aaa; text-align: center; padding: 10px;">No hay r√©cords a√∫n</div>';
                return;
            }
            
            records.forEach((record, index) => {
                const recordDiv = document.createElement('div');
                recordDiv.className = 'record-item';
                recordDiv.innerHTML = `
                    <span class="record-score">#${index + 1}: ${record.score} pts</span>
                    <span class="record-date">${record.date}</span>
                `;
                recordsListElement.appendChild(recordDiv);
            });
        }

        // Obtener r√©cords desde localStorage
        function getRecords() {
            const recordsJson = localStorage.getItem('snakeRecords');
            if (recordsJson) {
                return JSON.parse(recordsJson);
            }
            return [];
        }

        // Guardar nuevo r√©cord
        function saveRecord(newScore) {
            const records = getRecords();
            const now = new Date();
            const dateStr = `${now.getDate()}/${now.getMonth() + 1}/${now.getFullYear()} ${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')}`;
            
            records.push({
                score: newScore,
                date: dateStr,
                timestamp: now.getTime()
            });
            
            // Ordenar por puntaje (mayor a menor)
            records.sort((a, b) => b.score - a.score);
            
            // Mantener solo los 10 mejores
            const topRecords = records.slice(0, 10);
            
            localStorage.setItem('snakeRecords', JSON.stringify(topRecords));
            
            return topRecords;
        }

        // Variable para animaci√≥n de comida
        let foodPulse = 0;
        // Variable para efecto de destello cuando come
        let flashEffect = null;
        // Direcci√≥n anterior para saber hacia d√≥nde mira la serpiente
        let prevDx = 0;
        let prevDy = 0;

        // Dibujar grid futurista
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }
        }

        // Dibujar la serpiente con cara realista y robusta
        function drawSnake() {
            snake.forEach((segment, index) => {
                const x = segment.x * gridSize;
                const y = segment.y * gridSize;
                const centerX = x + gridSize / 2;
                const centerY = y + gridSize / 2;
                
                if (index === 0) {
                    // CABEZA ROBUSTA Y REALISTA
                    // Determinar direcci√≥n de la cabeza
                    let headDirX = dx !== 0 ? dx : (prevDx !== 0 ? prevDx : 1);
                    let headDirY = dy !== 0 ? dy : (prevDy !== 0 ? prevDy : 0);
                    
                    // Cabeza m√°s grande y robusta (ligeramente m√°s grande que el cuerpo)
                    const headSize = gridSize + 2;
                    const headOffset = (headSize - gridSize) / 2;
                    
                    // Gradiente para la cabeza
                    const headGradient = ctx.createRadialGradient(
                        centerX - headDirX * 2, centerY - headDirY * 2, 0,
                        centerX, centerY, headSize/2
                    );
                    headGradient.addColorStop(0, '#00ffff');
                    headGradient.addColorStop(0.4, '#0088ff');
                    headGradient.addColorStop(0.7, '#0055aa');
                    headGradient.addColorStop(1, '#003366');
                    
                    // Brillo externo de la cabeza
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#00ffff';
                    ctx.fillStyle = headGradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, headSize/2 - 1, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Detalles de la cara: ojos
                    ctx.shadowBlur = 0;
                    
                    // Ojos (dependiendo de la direcci√≥n de movimiento)
                    let eye1X, eye1Y, eye2X, eye2Y;
                    
                    // Si se mueve horizontalmente
                    if (headDirX !== 0) {
                        if (headDirX === 1) {
                            // Mirando a la derecha
                            eye1X = centerX - 3;
                            eye1Y = centerY - 4;
                            eye2X = centerX - 3;
                            eye2Y = centerY + 4;
                        } else {
                            // Mirando a la izquierda
                            eye1X = centerX + 3;
                            eye1Y = centerY - 4;
                            eye2X = centerX + 3;
                            eye2Y = centerY + 4;
                        }
                    } 
                    // Si se mueve verticalmente
                    else if (headDirY !== 0) {
                        if (headDirY === -1) {
                            // Mirando arriba
                            eye1X = centerX - 4;
                            eye1Y = centerY + 3;
                            eye2X = centerX + 4;
                            eye2Y = centerY + 3;
                        } else {
                            // Mirando abajo
                            eye1X = centerX - 4;
                            eye1Y = centerY - 3;
                            eye2X = centerX + 4;
                            eye2Y = centerY - 3;
                        }
                    }
                    // Si no se ha movido todav√≠a (estado inicial)
                    else {
                        // Por defecto mirando a la derecha
                        eye1X = centerX - 3;
                        eye1Y = centerY - 4;
                        eye2X = centerX - 3;
                        eye2Y = centerY + 4;
                    }
                    
                    // Pupilas brillantes
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(eye1X, eye1Y, 3, 0, Math.PI * 2);
                    ctx.arc(eye2X, eye2Y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Iris
                    ctx.fillStyle = '#0000ff';
                    ctx.beginPath();
                    ctx.arc(eye1X, eye1Y, 2, 0, Math.PI * 2);
                    ctx.arc(eye2X, eye2Y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Brillo en los ojos
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(eye1X - 0.5, eye1Y - 0.5, 1, 0, Math.PI * 2);
                    ctx.arc(eye2X - 0.5, eye2Y - 0.5, 1, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Boca peque√±a (en la direcci√≥n del movimiento)
                    ctx.strokeStyle = '#0088ff';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    if (headDirX === 1) {
                        // Mirando a la derecha
                        ctx.arc(centerX + 5, centerY, 3, 0, Math.PI * 2);
                    } else if (headDirX === -1) {
                        // Mirando a la izquierda
                        ctx.arc(centerX - 5, centerY, 3, 0, Math.PI * 2);
                    } else if (headDirY === -1) {
                        // Mirando arriba
                        ctx.arc(centerX, centerY + 5, 3, 0, Math.PI * 2);
                    } else if (headDirY === 1) {
                        // Mirando abajo
                        ctx.arc(centerX, centerY - 5, 3, 0, Math.PI * 2);
                    } else {
                        // Por defecto (estado inicial)
                        ctx.arc(centerX + 5, centerY, 3, 0, Math.PI * 2);
                    }
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                } else {
                    // CUERPO CON ESCAMAS
                    const intensity = Math.max(0.4, 1 - (index * 0.08));
                    const r = Math.floor(0 * intensity);
                    const g = Math.floor(255 * intensity);
                    const b = Math.floor(255 * intensity);
                    
                    // Efecto de escamas (patr√≥n)
                    ctx.shadowBlur = Math.max(5, 20 - (index * 0.3));
                    ctx.shadowColor = `rgba(0, ${g}, ${b}, 0.6)`;
                    
                    // Cuerpo con forma m√°s ovalada
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, (gridSize - 2) / 2, (gridSize - 2) / 2 * 0.9, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Detalle de escama (peque√±o brillo)
                    if (index % 2 === 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.3})`;
                        ctx.beginPath();
                        ctx.ellipse(centerX - 2, centerY - 2, 2, 1.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
            ctx.shadowBlur = 0; // Resetear sombra
        }

        // Dibujar la manzana realista
        function drawFood() {
            foodPulse += 0.1;
            const x = food.x * gridSize + gridSize/2;
            const y = food.y * gridSize + gridSize/2;
            const baseSize = gridSize - 4;
            const pulseScale = Math.sin(foodPulse) * 0.05 + 1;
            const size = baseSize * pulseScale;
            
            // Brillo externo pulsante (ne√≥n)
            const glowSize = Math.sin(foodPulse * 2) * 3 + 12;
            ctx.shadowBlur = glowSize;
            ctx.shadowColor = '#ff0080';
            
            // FORMA DE MANZANA (no perfectamente redonda, m√°s ovalada)
            ctx.save();
            
            // Cuerpo principal de la manzana con gradiente rojo
            const appleGradient = ctx.createRadialGradient(
                x - size/4, y - size/4, 0,
                x, y, size/2
            );
            appleGradient.addColorStop(0, '#ff4444');
            appleGradient.addColorStop(0.4, '#ff0000');
            appleGradient.addColorStop(0.7, '#cc0000');
            appleGradient.addColorStop(1, '#990000');
            
            ctx.fillStyle = appleGradient;
            ctx.beginPath();
            // Forma de manzana (m√°s ancha arriba, m√°s estrecha abajo)
            ctx.ellipse(x, y, size/2 * 0.85, size/2 * 0.95, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Brillo/highlight en la parte superior
            ctx.fillStyle = 'rgba(255, 200, 200, 0.6)';
            ctx.beginPath();
            ctx.ellipse(x - size/4, y - size/3, size/4, size/6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // TALLO (peque√±o)
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - size/2);
            ctx.lineTo(x, y - size/2 - 3);
            ctx.stroke();
            
            // HOJA
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.ellipse(x + 2, y - size/2 - 1, 3, 2, Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Detalle de la hoja (vena)
            ctx.strokeStyle = '#008800';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(x + 2, y - size/2 - 1);
            ctx.lineTo(x + 4, y - size/2 - 2);
            ctx.stroke();
            
            // Brillo interno futurista
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ffffff';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(x - size/4, y - size/3, size/8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            ctx.shadowBlur = 0; // Resetear sombra
        }
        
        // Dibujar efecto de destello cuando come
        function drawFlashEffect() {
            if (!flashEffect) return;
            
            const { x, y, time, maxTime } = flashEffect;
            const progress = time / maxTime;
            const alpha = 1 - progress;
            const radius = progress * gridSize * 3;
            
            // Part√≠culas de destello
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i + progress * Math.PI * 2;
                const distance = radius * 0.8;
                const px = x + Math.cos(angle) * distance;
                const py = y + Math.sin(angle) * distance;
                
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffff00';
                ctx.beginPath();
                ctx.arc(px, py, 4 * (1 - progress), 0, Math.PI * 2);
                ctx.fill();
            }
            
            // C√≠rculo de destello principal
            ctx.fillStyle = `rgba(255, 255, 0, ${alpha * 0.3})`;
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ffff00';
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Actualizar tiempo
            flashEffect.time += 16; // ~60fps
            if (flashEffect.time >= flashEffect.maxTime) {
                flashEffect = null;
            }
        }

        // Dibujar todo en el canvas
        function draw() {
            // Limpiar el canvas (fondo negro profundo)
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar grid futurista
            drawGrid();
            
            // Dibujar la serpiente
            drawSnake();
            
            // Dibujar la comida
            drawFood();
            
            // Dibujar efecto de destello si existe
            drawFlashEffect();
        }

        // Mover la serpiente
        function moveSnake() {
            // Si no hay direcci√≥n, no mover
            if (dx === 0 && dy === 0) return;

            // Crear nueva cabeza en la direcci√≥n del movimiento
            const head = {
                x: snake[0].x + dx,
                y: snake[0].y + dy
            };

            // Verificar colisi√≥n con las paredes
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                endGame();
                return;
            }

            // Verificar colisi√≥n consigo misma
            for (let segment of snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    endGame();
                    return;
                }
            }

            // Agregar nueva cabeza
            snake.unshift(head);

            // Verificar si come la comida
            if (head.x === food.x && head.y === food.y) {
                // Aumentar puntaje
                score += 10;
                scoreElement.textContent = score;
                
                // Actualizar velocidad (aumenta progresivamente)
                updateGameSpeed();
                
                // Activar efecto de destello
                const foodX = food.x * gridSize + gridSize/2;
                const foodY = food.y * gridSize + gridSize/2;
                flashEffect = {
                    x: foodX,
                    y: foodY,
                    time: 0,
                    maxTime: 500 // Duraci√≥n del destello en milisegundos
                };
                
                // Generar nueva comida
                generateFood();
            } else {
                // Si no come, quitar la cola
                snake.pop();
            }
            
            // Guardar direcci√≥n anterior
            if (dx !== 0 || dy !== 0) {
                prevDx = dx;
                prevDy = dy;
            }
        }

        // Actualizar el juego (solo dibujado)
        function update() {
            draw(); // Siempre dibujar para animar la comida
        }

        // Finalizar el juego
        function endGame() {
            gameRunning = false;
            
            // Detener intervalo
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
            
            finalScoreElement.textContent = score;
            
            // Guardar r√©cord si hay puntaje
            if (score > 0) {
                saveRecord(score);
            }
            
            gameOverElement.classList.add('show');
        }

        // Reiniciar el juego
        function restartGame() {
            snake = [{ x: 10, y: 10 }];
            dx = 0;
            dy = 0;
            prevDx = 0;
            prevDy = 0;
            score = 0;
            scoreElement.textContent = score;
            gameRunning = true;
            flashEffect = null; // Limpiar efecto de destello
            
            // Reiniciar velocidad
            baseSpeed = 150;
            currentSpeed = 150;
            speedLevel = 1;
            speedLevelElement.textContent = speedLevel;
            
            // Reiniciar intervalo
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            gameInterval = setInterval(() => {
                if (gameRunning) {
                    moveSnake();
                }
            }, currentSpeed);
            
            generateFood();
            gameOverElement.classList.remove('show');
            draw();
        }

        // Control del teclado
        document.addEventListener('keydown', (e) => {
            // Prevenir scroll cuando se presionan las flechas
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || 
                e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault();
            }

            // Solo permitir cambios de direcci√≥n si el juego est√° corriendo
            if (!gameRunning) return;

            // Prevenir movimiento inverso
            switch(e.key) {
                case 'ArrowUp':
                    if (dy !== 1) {
                        dx = 0;
                        dy = -1;
                    }
                    break;
                case 'ArrowDown':
                    if (dy !== -1) {
                        dx = 0;
                        dy = 1;
                    }
                    break;
                case 'ArrowLeft':
                    if (dx !== 1) {
                        dx = -1;
                        dy = 0;
                    }
                    break;
                case 'ArrowRight':
                    if (dx !== -1) {
                        dx = 1;
                        dy = 0;
                    }
                    break;
            }
        });

        // Controles m√≥viles (t√°ctiles)
        function handleDirection(directionX, directionY) {
            if (!gameRunning) return;
            
            // Prevenir movimiento inverso
            if (directionY === -1 && dy !== 1) {
                dx = 0;
                dy = -1;
            } else if (directionY === 1 && dy !== -1) {
                dx = 0;
                dy = 1;
            } else if (directionX === -1 && dx !== 1) {
                dx = -1;
                dy = 0;
            } else if (directionX === 1 && dx !== -1) {
                dx = 1;
                dy = 0;
            }
        }

        // Funci√≥n para prevenir eventos por defecto y propagaci√≥n
        function preventDefaults(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
            return false;
        }

        // Inicializar controles m√≥viles cuando el DOM est√© listo
        function initMobileControls() {
            const btnUp = document.getElementById('btnUp');
            const btnDown = document.getElementById('btnDown');
            const btnLeft = document.getElementById('btnLeft');
            const btnRight = document.getElementById('btnRight');

            if (!btnUp || !btnDown || !btnLeft || !btnRight) {
                // Los botones no est√°n disponibles a√∫n, reintentar despu√©s
                return false;
            }

            // Funci√≥n helper para agregar eventos a un bot√≥n
            function setupMobileButton(button, directionX, directionY) {
                if (!button) return;

                // Evento touchstart - principal para m√≥viles
                button.addEventListener('touchstart', function(e) {
                    preventDefaults(e);
                    handleDirection(directionX, directionY);
                }, { passive: false });

                // Evento touchend
                button.addEventListener('touchend', function(e) {
                    preventDefaults(e);
                }, { passive: false });

                // Evento touchcancel
                button.addEventListener('touchcancel', function(e) {
                    preventDefaults(e);
                }, { passive: false });

                // Evento click (fallback para navegadores que no soportan touch)
                button.addEventListener('click', function(e) {
                    preventDefaults(e);
                    handleDirection(directionX, directionY);
                });

                // Prevenir scroll
                button.addEventListener('touchmove', function(e) {
                    preventDefaults(e);
                }, { passive: false });

                // Prevenir selecci√≥n de texto y otros eventos
                button.addEventListener('selectstart', preventDefaults);
                button.addEventListener('contextmenu', preventDefaults);
            }

            // Configurar cada bot√≥n
            setupMobileButton(btnUp, 0, -1);
            setupMobileButton(btnDown, 0, 1);
            setupMobileButton(btnLeft, -1, 0);
            setupMobileButton(btnRight, 1, 0);

            return true;
        }

        // Intentar inicializar controles m√≥viles
        function tryInitMobileControls() {
            if (initMobileControls()) {
                console.log('Controles m√≥viles inicializados correctamente');
            } else {
                // Reintentar si los botones no est√°n disponibles
                setTimeout(tryInitMobileControls, 50);
            }
        }

        // Inicializar controles m√≥viles cuando el DOM est√© listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', tryInitMobileControls);
        } else {
            // DOM ya est√° listo, intentar inmediatamente y con delay
            tryInitMobileControls();
            setTimeout(tryInitMobileControls, 100);
        }

        // Iniciar el juego
        draw();
        
        // Actualizar animaci√≥n de forma fluida (60 FPS para la comida)
        function gameLoop() {
            update();
            requestAnimationFrame(gameLoop);
        }
        
        // Inicializar intervalo de movimiento
        gameInterval = setInterval(() => {
            if (gameRunning) {
                moveSnake();
            }
        }, currentSpeed);
        
        // Loop de animaci√≥n visual (fluido)
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
